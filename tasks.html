<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tasks Overview</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Chart.js for charts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <!-- jsPDF for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- html2canvas for chart rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    /* [All your existing CSS styles remain exactly the same] */
    /* Reset & base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #6b73ff 0%, #000dff 100%);
      margin: 40px 0;
      color: #444;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container {
      background: white;
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow:
        0 4px 30px rgba(0, 0, 0, 0.25),
        0 10px 20px rgba(50, 50, 93, 0.1);
      width: 95%;
      max-width: 1400px;
    }

    h1 {
      text-align: center;
      margin-bottom: 25px;
      font-weight: 700;
      color: #222;
      text-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    /* [All other CSS styles remain exactly the same as your previous working version] */
    /* ... existing CSS ... */

    /* Hidden chart container for PDF generation */
    .chart-container {
      position: fixed;
      left: -10000px;
      top: -10000px;
      width: 600px;
      height: 400px;
      background: white;
      z-index: -1;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="top-bar">
    <a href="Home.html" class="top-button">Home</a>
    <a href="Current task.html" class="top-button">Current Works</a>
  </div>

  <h1>Tasks Overview</h1>

  <div class="filters">
    <input type="text" id="searchCompany" placeholder="Search Company Name" />
    <input type="text" id="searchOwner" placeholder="Search Owner" />
    <select id="statusFilter">
      <option value="">All Status</option>
      <option value="Not Started">Not Started</option>
      <option value="In Progress">In Progress</option>
      <option value="Pending">Pending</option>
      <option value="Complete">Completed</option>
    </select>
    
    <div class="date-filter-section">
      <select id="dateFilter">
        <option value="">All Dates</option>
        <option value="today">Today</option>
        <option value="yesterday">Yesterday</option>
        <option value="thisWeek">This Week</option>
        <option value="lastWeek">Last Week</option>
        <option value="thisMonth">This Month</option>
        <option value="lastMonth">Last Month</option>
        <option value="custom">Custom Range</option>
      </select>
      
      <input type="date" id="customDateStart" style="display: none;" placeholder="Start Date">
      <input type="date" id="customDateEnd" style="display: none;" placeholder="End Date">
    </div>
  </div>

  <table id="tasksTable" class="overview-table">
    <thead>
      <tr>
        <th>SINO</th>
        <th>Existing Company Name</th>
        <th>TYPE OF WORK</th>
        <th>Status</th>
        <th>Owner</th>
        <th>Due Date</th>
      </tr>
    </thead>
    <tbody>
      <!-- Rows appended by JS -->
    </tbody>
  </table>

  <div id="paginationControls" class="pagination" style="margin-top: 20px;"></div>
</div>

<!-- Hidden chart container for PDF generation -->
<div id="pdfCharts" class="chart-container"></div>

<!-- [All your existing modals and floating buttons remain the same] -->
<!-- Modal for Creating/Editing Task -->
<div id="taskModal" style="display:none;">
  <div>
    <h3 id="modalTitle">Create New Task</h3>
    <form id="taskForm">
      <div class="form-section">
        <h4><i class="fas fa-building"></i> Company Information</h4>
        <input list="companyList" name="company" id="companyInput" placeholder="Company Name" required />
        <datalist id="companyList"></datalist>

        <input list="workTypeList" name="typeOfWork" id="typeOfWorkInput" placeholder="TYPE OF WORK" required />
        <datalist id="workTypeList"></datalist>

        <select name="accountType" id="accountTypeSelect">
          <option value="">Select ACCOUNT TYPE</option>
          <option value="Saving Acc">Saving Acc</option>
          <option value="Chequing Acc">Chequing Acc</option>
          <option value="Loan Acc">Loan Acc</option>
          <option value="Credit Card">Credit Card</option>
          <option value="Other">Other</option>
        </select>

        <input type="text" name="accountsCards" id="accountsCards" placeholder="Accounts / Cards" list="accountsCardsList"/>
        <datalist id="accountsCardsList"></datalist>
      </div>

      <div class="form-section">
        <h4><i class="fas fa-tasks"></i> Task Details</h4>
        <input type="text" name="task" placeholder="Task" />

        <select name="workFor" id="workForSelect">
          <option value="">Select WORK FOR</option>
          <option value="Yearly">Yearly</option>
          <option value="Monthly">Monthly</option>
          <option value="Weekly">Weekly</option>
          <option value="Daily">Daily</option>
          <option value="Custom">Custom</option>
        </select>

        <input type="text" name="period" id="periodInput" placeholder="PERIOD" style="display:none;" />

        <input type="date" name="dueDate" required />
      </div>

      <div class="form-section">
        <h4><i class="fas fa-users"></i> Assignment</h4>
        <select name="owner" id="ownerSelect" required>
          <option value="">Select Owner</option>
        </select>

        <select name="assignedBy" id="assignedBySelect" required>
          <option value="">Select Assigned By</option>
        </select>
      </div>

      <div class="form-section">
        <h4><i class="fas fa-sticky-note"></i> Additional Information</h4>
        <textarea name="notes" placeholder="Notes" rows="3"></textarea>
      </div>
      
      <!-- Time Editing Section - Hidden by default, shown only in edit mode -->
      <div class="time-edit-section" id="timeEditSection">
        <h4><i class="fas fa-clock"></i> Time Tracking</h4>
        <div class="time-input-group">
          <input type="datetime-local" id="timeStartInput" placeholder="Start Time">
          <input type="datetime-local" id="timeEndInput" placeholder="End Time">
        </div>
        <div class="time-input-group">
          <input type="text" id="totalWorkHours" placeholder="Total Work Hours" readonly>
          <input type="text" id="totalPauseHours" placeholder="Total Pause Hours" readonly>
        </div>
        <input type="text" id="remarksInput" placeholder="Remarks">
      </div>

      <div style="display: flex; justify-content: space-between; margin-top: 20px;">
        <button type="submit">Save Task</button>
        <button type="button" onclick="document.getElementById('taskModal').style.display='none'">Cancel</button>
      </div>
    </form> 
  </div>
</div>

<!-- Modal for Adding New Person -->
<div id="addPersonModal" style="display:none;">
  <div>
    <h3 id="addPersonModalTitle">Add New Person</h3>
    <form id="addPersonForm">
      <input type="text" id="newPersonName" placeholder="Enter Name" required />
      <select id="personType">
        <option value="owner">Owner</option>
        <option value="assignedBy">Assigned By</option>
      </select><br/>
      <button type="submit">Add Person</button>
      <button type="button" onclick="document.getElementById('addPersonModal').style.display='none'">Cancel</button>
    </form>
  </div>
</div>

<!-- Floating Buttons -->
<button id="createTaskBtn">+</button>
<input type="file" id="csvUpload" style="display:none" accept=".csv" />
<button id="uploadCSVBtn"><i class="fas fa-upload"></i></button>
<button id="downloadTemplateBtn"><i class="fas fa-download"></i></button>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<!-- PapaParse CSV Parser -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<script>
// Initialize jsPDF
const { jsPDF } = window.jspdf;

let editingTaskId = null;
let currentPersonType = null;

// Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyDYhLNuJKj2ucwGimfddTfpTb32Y0c-bXg",
  authDomain: "mytask-96a79.firebaseapp.com",
  databaseURL: "https://mytask-96a79-default-rtdb.firebaseio.com",
  projectId: "mytask-96a79",
  storageBucket: "mytask-96a79.firebasestorage.app",
  messagingSenderId: "963509757773",
  appId: "1:963509757773:web:d9c81a108f5873702eb904",
  measurementId: "G-L9C1LTCZRN"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// DOM Elements
const taskTableBody = document.querySelector('#tasksTable tbody');
const paginationDiv = document.getElementById('paginationControls');
const searchCompany = document.getElementById('searchCompany');
const searchOwner = document.getElementById('searchOwner');
const statusFilter = document.getElementById('statusFilter');
const dateFilter = document.getElementById('dateFilter');
const customDateStart = document.getElementById('customDateStart');
const customDateEnd = document.getElementById('customDateEnd');
const createTaskBtn = document.getElementById('createTaskBtn');
const taskModal = document.getElementById('taskModal');
const taskForm = document.getElementById('taskForm');
const ownerSelect = document.getElementById('ownerSelect');
const assignedBySelect = document.getElementById('assignedBySelect');
const companyInput = taskForm.elements['company'];
const modalTitle = document.getElementById('modalTitle');
const uploadCSVBtn = document.getElementById('uploadCSVBtn');
const csvUpload = document.getElementById('csvUpload');
const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
const addPersonModal = document.getElementById('addPersonModal');
const addPersonForm = document.getElementById('addPersonForm');
const newPersonName = document.getElementById('newPersonName');
const personType = document.getElementById('personType');
const timeEditSection = document.getElementById('timeEditSection');
const pdfCharts = document.getElementById('pdfCharts');

const rowsPerPage = 10;
let currentPage = 1;
let allTasks = [];
let filteredTasks = [];

// Load tasks from Firestore
async function loadTasks() {
  try {
    const snapshot = await db.collection('tasks').get();
    allTasks = []; // reset on reload
    snapshot.forEach(doc => {
      allTasks.push({ id: doc.id, ...doc.data() });
    });

    // Sort ascending by numeric part of SINO
    allTasks.sort((a, b) => {
      const getNumber = sino => {
        if (!sino) return 0;
        const match = sino.match(/(\d+)$/);
        return match ? parseInt(match[1], 10) : 0;
      };
      return getNumber(a.SINO) - getNumber(b.SINO);
    });

    // Auto-calculate time information for all tasks
    allTasks.forEach(task => {
      calculateAndUpdateTaskTimeInfo(task);
    });
    
    populateCompanyList();
    applyFilters(); // Initial render with sorting applied
  } catch (error) {
    console.error(error);
  }
}

// Calculate time information from work sessions
function calculateAndUpdateTaskTimeInfo(task) {
  if (!task.workSessions || task.workSessions.length === 0) {
    return {
      totalWorkHours: '0h 0m',
      totalPauseHours: '0h 0m',
      startTime: null,
      endTime: null,
      sessionCount: 0
    };
  }

  let totalWorkMs = 0;
  let totalPauseMs = 0;
  let lastEndTime = null;

  // Calculate work time and pause time from sessions
  task.workSessions.forEach(session => {
    const start = session.start ? (session.start.toDate ? session.start.toDate() : new Date(session.start)) : null;
    const end = session.end ? (session.end.toDate ? session.end.toDate() : new Date(session.end)) : null;
    
    if (start) {
      const sessionStartMs = start.getTime();
      const sessionEndMs = end ? end.getTime() : Date.now(); // Use current time if session is still active
      
      // Add work time for this session
      totalWorkMs += sessionEndMs - sessionStartMs;
      
      // Calculate pause time between sessions
      if (lastEndTime !== null) {
        const pauseTime = sessionStartMs - lastEndTime;
        if (pauseTime > 0) {
          totalPauseMs += pauseTime;
        }
      }
      
      lastEndTime = sessionEndMs;
    }
  });

  // Convert milliseconds to hours and minutes
  const formatTime = (ms) => {
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    return `${hours}h ${minutes}m`;
  };

  const firstSession = task.workSessions[0];
  const lastSession = task.workSessions[task.workSessions.length - 1];
  
  const startTime = firstSession.start ? 
    (firstSession.start.toDate ? firstSession.start.toDate() : new Date(firstSession.start)) : null;
  const endTime = lastSession.end ? 
    (lastSession.end.toDate ? lastSession.end.toDate() : new Date(lastSession.end)) : null;

  // Update task object with calculated times
  task.calculatedWorkHours = formatTime(totalWorkMs);
  task.calculatedPauseHours = formatTime(totalPauseMs);
  task.calculatedStartTime = startTime;
  task.calculatedEndTime = endTime;
  task.sessionCount = task.workSessions.length;

  return {
    totalWorkHours: task.calculatedWorkHours,
    totalPauseHours: task.calculatedPauseHours,
    startTime: task.calculatedStartTime,
    endTime: task.calculatedEndTime,
    sessionCount: task.sessionCount
  };
}

function populateCompanyList() {
  const companyList = document.getElementById('companyList');
  companyList.innerHTML = ''; // Clear previous options

  const companiesSet = new Set();

  allTasks.forEach(task => {
    const company = task['Existing Company Name'];
    if (company) {
      companiesSet.add(company);
    }
  });

  companiesSet.forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    companyList.appendChild(option);
  });
}

// Render a specific page
function renderTablePage(page, tasks) {
  taskTableBody.innerHTML = '';
  const start = (page - 1) * rowsPerPage;
  const pageTasks = tasks.slice(start, start + rowsPerPage);

  pageTasks.forEach(task => {
    const tr = document.createElement('tr');
    tr.classList.add('task-row');
    
    // Create status badge
    let statusClass = '';
    if (task.Status === 'Not Started') statusClass = 'status-not-started';
    else if (task.Status === 'Complete') statusClass = 'status-complete';
    else if (task.Status === 'In Progress') statusClass = 'status-progress';
    else if (task.Status === 'Pending') statusClass = 'status-pending';
    
    tr.innerHTML = `
      <td>${task.SINO || ''}</td>
      <td>${task['Existing Company Name'] || ''}</td>
      <td>${task['TYPE OF WORK'] || ''}</td>
      <td><span class="status-badge ${statusClass}">${task.Status || ''}</span></td>
      <td>${task.Owner || ''}</td>
      <td>${task['Due date'] || ''}</td>
    `;

    const detailsTr = document.createElement('tr');
    detailsTr.classList.add('details-row');
    detailsTr.style.display = 'none';
    
    // Calculate time information for this task
    const timeInfo = calculateAndUpdateTaskTimeInfo(task);
    
    // Show time information for all tasks that have work sessions
    let timeInfoHtml = '';
    
    if (task.workSessions && task.workSessions.length > 0) {
      timeInfoHtml = `
        <div class="time-info">
          <strong><i class="fas fa-clock"></i> Time Tracking Summary</strong>
          <div class="time-info-grid">
            <div class="time-info-item">
              <span class="time-info-label">Start Time</span>
              <span class="time-info-value">${timeInfo.startTime ? timeInfo.startTime.toLocaleString() : 'Not started'}</span>
            </div>
            <div class="time-info-item">
              <span class="time-info-label">End Time</span>
              <span class="time-info-value">${timeInfo.endTime ? timeInfo.endTime.toLocaleString() : 'In progress'}</span>
            </div>
            <div class="time-info-item">
              <span class="time-info-label">Total Work</span>
              <span class="time-info-value">${timeInfo.totalWorkHours}</span>
            </div>
            <div class="time-info-item">
              <span class="time-info-label">Total Pause</span>
              <span class="time-info-value">${timeInfo.totalPauseHours}</span>
            </div>
            <div class="time-info-item">
              <span class="time-info-label">Work Sessions</span>
              <span class="time-info-value">${timeInfo.sessionCount} sessions</span>
            </div>
          </div>
        </div>
      `;
    }
    
    detailsTr.innerHTML = `
      <td colspan="6">
        <div class="details-box">
          <strong>ACCOUNT TYPE:</strong> ${task['ACCOUNT TYPE'] || ''}<br/>
          <strong>Accounts / Cards:</strong> ${task['Accounts / Cards'] || ''}<br/>
          <strong>Task:</strong> ${task.Task || ''}<br/>
          <strong>WORK FOR:</strong> ${task['WORK FOR'] || ''}<br/>
          <strong>PERIOD:</strong> ${task.PERIOD || ''}<br/>
          <strong>Due Date:</strong> ${task['Due date'] || ''}<br/>
          <strong>Assigned By:</strong> ${task['Assigned By'] || ''}<br/>
          <strong>Notes:</strong> ${task.Notes || ''}<br/>
          ${timeInfoHtml}
          <div style="margin-top: 15px;">
            <button class="edit-btn action-btn" data-id="${task.id}">Edit</button>
            <button class="delete-btn action-btn" data-id="${task.id}">Delete</button>
            <button class="download-btn action-btn" data-id="${task.id}">
              <i class="fas fa-download"></i> Download Report
            </button>
          </div>
        </div>
      </td>
    `;

    tr.addEventListener('click', () => {
      detailsTr.style.display = detailsTr.style.display === 'none' ? 'table-row' : 'none';
    });

    taskTableBody.appendChild(tr);
    taskTableBody.appendChild(detailsTr);
  });

  attachRowEventListeners();
}

// Format time in detailed format
function formatTimeDetailed(ms) {
  const hours = Math.floor(ms / (1000 * 60 * 60));
  const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((ms % (1000 * 60)) / 1000);
  return `${hours}h ${minutes}m ${seconds}s`;
}

// Format time for charts (decimal hours)
function formatTimeForCharts(timeStr) {
  if (!timeStr) return 0;
  const match = timeStr.match(/(\d+)h\s*(\d+)m/);
  if (match) {
    const hours = parseInt(match[1]);
    const minutes = parseInt(match[2]);
    return hours + (minutes / 60);
  }
  return 0;
}

// Attach edit/delete/download button events
function attachRowEventListeners() {
  document.querySelectorAll('.delete-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.dataset.id;
      if (confirm('Delete this task?')) {
        try {
          await db.collection('tasks').doc(id).delete();
          alert('Deleted');
          loadTasks();
        } catch (err) {
          console.error(err);
          alert('Delete failed');
        }
      }
    });
  });

  document.querySelectorAll('.edit-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.dataset.id;
      const task = allTasks.find(t => t.id === id);
      if (!task) return alert('Task not found');

      editingTaskId = id; // Track the task being edited
      modalTitle.textContent = 'Edit Task';
      populateDropdowns(); // Ensure dropdowns are filled
      taskForm.reset(); // Clear previous data

      // Show time editing section for existing tasks
      timeEditSection.style.display = 'block';

      // Populate form fields
      taskForm.elements['company'].value = task['Existing Company Name'] || '';
      taskForm.elements['typeOfWork'].value = task['TYPE OF WORK'] || '';
      taskForm.elements['accountType'].value = task['ACCOUNT TYPE'] || '';
      taskForm.elements['accountsCards'].value = task['Accounts / Cards'] || '';
      taskForm.elements['task'].value = task.Task || '';
      taskForm.elements['owner'].value = task.Owner || '';
      taskForm.elements['workFor'].value = task['WORK FOR'] || '';
      taskForm.elements['period'].value = task.PERIOD || '';
      taskForm.elements['dueDate'].value = task['Due date'] || '';
      taskForm.elements['assignedBy'].value = task['Assigned By'] || '';
      taskForm.elements['notes'].value = task.Notes || '';
      
      // Populate time fields with calculated values
      const timeInfo = calculateAndUpdateTaskTimeInfo(task);
      document.getElementById('timeStartInput').value = timeInfo.startTime ? formatDateTimeLocal(timeInfo.startTime) : '';
      document.getElementById('timeEndInput').value = timeInfo.endTime ? formatDateTimeLocal(timeInfo.endTime) : '';
      document.getElementById('totalWorkHours').value = timeInfo.totalWorkHours || '';
      document.getElementById('totalPauseHours').value = timeInfo.totalPauseHours || '';
      document.getElementById('remarksInput').value = task.Remarks || '';

      taskModal.style.display = 'flex';
    });
  });

  document.querySelectorAll('.download-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.closest('.download-btn').dataset.id;
      await generateTaskReport(id);
    });
  });
}

// Create chart and convert to image data URL
async function createChartImage(chartConfig) {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 350;
    const ctx = canvas.getContext('2d');

    // Create chart
    new Chart(ctx, chartConfig);

    // Convert to image after a delay to ensure chart is rendered
    setTimeout(() => {
      const imageData = canvas.toDataURL('image/png');
      resolve(imageData);
    }, 500);
  });
}

// Generate comprehensive PDF report for a task
async function generateTaskReport(taskId) {
  const task = allTasks.find(t => t.id === taskId);
  if (!task) {
    alert('Task not found');
    return;
  }

  // Show loading state on the button
  const downloadBtn = document.querySelector(`.download-btn[data-id="${taskId}"]`);
  const originalHtml = downloadBtn.innerHTML;
  downloadBtn.innerHTML = '<div class="loading"></div> Generating PDF...';
  downloadBtn.disabled = true;

  try {
    // Calculate time information
    const timeInfo = calculateAndUpdateTaskTimeInfo(task);
    
    // Create PDF
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    let yPosition = 20;

    // Add elegant header
    pdf.setFillColor(58, 66, 244);
    pdf.rect(0, 0, pageWidth, 60, 'F');
    
    // Header content
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(24);
    pdf.setFont(undefined, 'bold');
    pdf.text('TASK PERFORMANCE REPORT', pageWidth / 2, 25, { align: 'center' });
    
    pdf.setFontSize(12);
    pdf.setFont(undefined, 'normal');
    pdf.text(`Generated on: ${new Date().toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })}`, pageWidth / 2, 35, { align: 'center' });
    
    pdf.setFontSize(10);
    pdf.text('Gliggo Task Management System', pageWidth / 2, 45, { align: 'center' });

    yPosition = 75;

    // Task Information Section
    pdf.setTextColor(58, 66, 244);
    pdf.setFontSize(16);
    pdf.setFont(undefined, 'bold');
    pdf.text('TASK INFORMATION', 20, yPosition);
    
    // Add underline
    pdf.setDrawColor(58, 66, 244);
    pdf.line(20, yPosition + 2, 80, yPosition + 2);
    
    yPosition += 15;

    pdf.setTextColor(0, 0, 0);
    pdf.setFontSize(10);
    pdf.setFont(undefined, 'normal');

    const taskInfo = [
      { label: 'Task ID', value: task.SINO || 'N/A' },
      { label: 'Company', value: task['Existing Company Name'] || 'N/A' },
      { label: 'Type of Work', value: task['TYPE OF WORK'] || 'N/A' },
      { label: 'Account Type', value: task['ACCOUNT TYPE'] || 'N/A' },
      { label: 'Accounts/Cards', value: task['Accounts / Cards'] || 'N/A' },
      { label: 'Task Description', value: task.Task || 'N/A' },
      { label: 'Work For', value: task['WORK FOR'] || 'N/A' },
      { label: 'Period', value: task.PERIOD || 'N/A' },
      { label: 'Due Date', value: task['Due date'] || 'N/A' },
      { label: 'Status', value: task.Status || 'N/A' },
      { label: 'Owner', value: task.Owner || 'N/A' },
      { label: 'Assigned By', value: task['Assigned By'] || 'N/A' }
    ];

    // Two column layout for task info
    const col1X = 20;
    const col2X = pageWidth / 2 + 10;
    let currentCol = col1X;

    taskInfo.forEach((info, index) => {
      if (yPosition > pageHeight - 50) {
        pdf.addPage();
        yPosition = 20;
      }
      
      pdf.setFont(undefined, 'bold');
      pdf.setTextColor(100, 100, 100);
      pdf.text(info.label + ':', currentCol, yPosition);
      
      pdf.setFont(undefined, 'normal');
      pdf.setTextColor(0, 0, 0);
      pdf.text(info.value, currentCol + 35, yPosition);
      
      yPosition += 6;
      
      // Switch column every 6 items
      if ((index + 1) % 6 === 0) {
        currentCol = currentCol === col1X ? col2X : col1X;
        yPosition = currentCol === col1X ? yPosition : 90;
      }
    });

    // Reset position after task info
    yPosition = Math.max(yPosition, 150);

    // Time Tracking Summary
    pdf.setTextColor(58, 66, 244);
    pdf.setFontSize(16);
    pdf.setFont(undefined, 'bold');
    pdf.text('TIME TRACKING SUMMARY', 20, yPosition);
    pdf.line(20, yPosition + 2, 100, yPosition + 2);
    yPosition += 15;

    pdf.setTextColor(0, 0, 0);
    pdf.setFontSize(10);
    
    const timeSummary = [
      { label: 'Start Time', value: timeInfo.startTime ? timeInfo.startTime.toLocaleString() : 'Not started' },
      { label: 'End Time', value: timeInfo.endTime ? timeInfo.endTime.toLocaleString() : 'In progress' },
      { label: 'Total Work Time', value: timeInfo.totalWorkHours },
      { label: 'Total Pause Time', value: timeInfo.totalPauseHours },
      { label: 'Work Sessions', value: `${timeInfo.sessionCount} sessions` },
      { label: 'Remarks', value: task.Remarks || 'No remarks provided' }
    ];

    timeSummary.forEach(info => {
      if (yPosition > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
      }
      
      pdf.setFont(undefined, 'bold');
      pdf.setTextColor(100, 100, 100);
      pdf.text(info.label + ':', 20, yPosition);
      
      pdf.setFont(undefined, 'normal');
      pdf.setTextColor(0, 0, 0);
      
      // Handle long text for remarks
      if (info.label === 'Remarks' && info.value.length > 80) {
        const remarksLines = pdf.splitTextToSize(info.value, pageWidth - 50);
        pdf.text(remarksLines, 60, yPosition);
        yPosition += (remarksLines.length * 5);
      } else {
        pdf.text(info.value, 60, yPosition);
        yPosition += 7;
      }
    });

    yPosition += 10;

    // Work Sessions Details
    if (task.workSessions && task.workSessions.length > 0) {
      if (yPosition > pageHeight - 100) {
        pdf.addPage();
        yPosition = 20;
      }
      
      pdf.setTextColor(58, 66, 244);
      pdf.setFontSize(16);
      pdf.setFont(undefined, 'bold');
      pdf.text('DETAILED WORK SESSIONS', 20, yPosition);
      pdf.line(20, yPosition + 2, 110, yPosition + 2);
      yPosition += 15;

      // Table headers with better styling
      pdf.setFillColor(240, 240, 240);
      pdf.rect(20, yPosition, pageWidth - 40, 8, 'F');
      
      pdf.setTextColor(0, 0, 0);
      pdf.setFontSize(9);
      pdf.setFont(undefined, 'bold');
      
      const headers = ['Session', 'Start Time', 'End Time', 'Duration', 'Status'];
      const colWidths = [15, 55, 55, 30, 25];
      let xPosition = 22;

      headers.forEach((header, index) => {
        pdf.text(header, xPosition, yPosition + 6);
        xPosition += colWidths[index];
      });

      yPosition += 12;

      // Table rows
      pdf.setFont(undefined, 'normal');
      pdf.setFontSize(8);

      task.workSessions.forEach((session, index) => {
        if (yPosition > pageHeight - 20) {
          pdf.addPage();
          yPosition = 20;
          // Redraw headers on new page
          pdf.setFillColor(240, 240, 240);
          pdf.rect(20, yPosition, pageWidth - 40, 8, 'F');
          pdf.setFont(undefined, 'bold');
          pdf.setFontSize(9);
          xPosition = 22;
          headers.forEach((header, i) => {
            pdf.text(header, xPosition, yPosition + 6);
            xPosition += colWidths[i];
          });
          yPosition += 12;
          pdf.setFont(undefined, 'normal');
          pdf.setFontSize(8);
        }

        const start = session.start ? 
          (session.start.toDate ? session.start.toDate() : new Date(session.start)).toLocaleString() : '—';
        const end = session.end ? 
          (session.end.toDate ? session.end.toDate() : new Date(session.end)).toLocaleString() : '—';
        const duration = session.start && session.end ? 
          formatTimeDetailed(new Date(session.end.seconds * 1000) - new Date(session.start.seconds * 1000)) : 
          (session.start && !session.end ? 'In Progress' : '—');
        const status = session.end ? 'Completed' : (session.start ? 'Active' : '—');

        xPosition = 22;
        const rowData = [
          (index + 1).toString(),
          start,
          end,
          duration,
          status
        ];

        // Alternate row background
        if (index % 2 === 0) {
          pdf.setFillColor(250, 250, 250);
          pdf.rect(20, yPosition - 4, pageWidth - 40, 6, 'F');
        }

        rowData.forEach((data, i) => {
          pdf.setTextColor(0, 0, 0);
          pdf.text(data, xPosition, yPosition);
          xPosition += colWidths[i];
        });

        yPosition += 7;
      });

      yPosition += 10;
    }

    // Add charts if there are work sessions
    if (task.workSessions && task.workSessions.length > 0) {
      // Add new page for charts
      pdf.addPage();
      yPosition = 30;

      // Time Distribution Chart section
      pdf.setTextColor(58, 66, 244);
      pdf.setFontSize(16);
      pdf.setFont(undefined, 'bold');
      pdf.text('TIME ANALYSIS CHARTS', 20, yPosition);
      pdf.line(20, yPosition + 2, 90, yPosition + 2);
      yPosition += 20;

      try {
        // Create time distribution chart
        const timeDistributionChart = {
          type: 'pie',
          data: {
            labels: ['Work Time', 'Pause Time'],
            datasets: [{
              data: [
                formatTimeForCharts(timeInfo.totalWorkHours),
                formatTimeForCharts(timeInfo.totalPauseHours)
              ],
              backgroundColor: ['#4CAF50', '#FF9800'],
              borderWidth: 2,
              borderColor: '#ffffff'
            }]
          },
          options: {
            responsive: false,
            plugins: {
              title: {
                display: true,
                text: 'Work vs Pause Time Distribution',
                font: { size: 14, weight: 'bold' }
              },
              legend: {
                position: 'bottom',
                labels: { font: { size: 12 } }
              }
            }
          }
        };

        // Create session duration chart
        const sessionDurations = task.workSessions.map(session => {
          if (session.start && session.end) {
            const start = session.start.toDate ? session.start.toDate() : new Date(session.start);
            const end = session.end.toDate ? session.end.toDate() : new Date(session.end);
            return (end - start) / (1000 * 60 * 60); // Convert to hours
          }
          return 0;
        }).filter(duration => duration > 0);

        const sessionChart = {
          type: 'bar',
          data: {
            labels: sessionDurations.map((_, i) => `Session ${i + 1}`),
            datasets: [{
              label: 'Duration (hours)',
              data: sessionDurations,
              backgroundColor: '#2196F3',
              borderColor: '#1976D2',
              borderWidth: 1
            }]
          },
          options: {
            responsive: false,
            plugins: {
              title: {
                display: true,
                text: 'Work Session Durations',
                font: { size: 14, weight: 'bold' }
              },
              legend: {
                display: false
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Hours'
                }
              }
            }
          }
        };

        // Generate chart images
        const timeDistributionImage = await createChartImage(timeDistributionChart);
        const sessionChartImage = await createChartImage(sessionChart);

        // Add charts to PDF
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        pdf.text('Time Distribution', 20, yPosition);
        pdf.addImage(timeDistributionImage, 'PNG', 20, yPosition + 5, 80, 60);
        
        pdf.text('Session Durations', 110, yPosition);
        pdf.addImage(sessionChartImage, 'PNG', 110, yPosition + 5, 80, 60);

        yPosition += 80;

      } catch (chartError) {
        console.error('Chart generation failed:', chartError);
        pdf.setFontSize(10);
        pdf.setTextColor(255, 0, 0);
        pdf.text('Charts could not be generated due to technical issues.', 20, yPosition);
        yPosition += 10;
      }
    }

    // Performance Metrics Section
    if (yPosition > pageHeight - 100) {
      pdf.addPage();
      yPosition = 30;
    }

    pdf.setTextColor(58, 66, 244);
    pdf.setFontSize(16);
    pdf.setFont(undefined, 'bold');
    pdf.text('PERFORMANCE METRICS', 20, yPosition);
    pdf.line(20, yPosition + 2, 85, yPosition + 2);
    yPosition += 20;

    pdf.setTextColor(0, 0, 0);
    pdf.setFontSize(10);

    // Calculate efficiency metrics
    const totalWorkHours = formatTimeForCharts(timeInfo.totalWorkHours);
    const totalPauseHours = formatTimeForCharts(timeInfo.totalPauseHours);
    const totalTime = totalWorkHours + totalPauseHours;
    const efficiency = totalTime > 0 ? (totalWorkHours / totalTime) * 100 : 0;

    const metrics = [
      { label: 'Work Efficiency', value: `${efficiency.toFixed(1)}%` },
      { label: 'Average Session Duration', value: timeInfo.sessionCount > 0 ? 
        `${(totalWorkHours / timeInfo.sessionCount).toFixed(2)} hours` : 'N/A' },
      { label: 'Task Completion Rate', value: task.Status === 'Complete' ? '100%' : 
        (timeInfo.endTime ? 'Completed (Time)' : 'In Progress') },
      { label: 'Time Utilization', value: `${totalWorkHours.toFixed(2)}h / ${totalTime.toFixed(2)}h` }
    ];

    metrics.forEach(metric => {
      pdf.setFont(undefined, 'bold');
      pdf.setTextColor(100, 100, 100);
      pdf.text(metric.label + ':', 20, yPosition);
      
      pdf.setFont(undefined, 'normal');
      pdf.setTextColor(0, 0, 0);
      pdf.text(metric.value, 70, yPosition);
      yPosition += 7;
    });

    yPosition += 10;

    // Notes Section
    if (task.Notes) {
      if (yPosition > pageHeight - 50) {
        pdf.addPage();
        yPosition = 20;
      }

      pdf.setTextColor(58, 66, 244);
      pdf.setFontSize(16);
      pdf.setFont(undefined, 'bold');
      pdf.text('ADDITIONAL NOTES', 20, yPosition);
      pdf.line(20, yPosition + 2, 75, yPosition + 2);
      yPosition += 15;

      pdf.setTextColor(0, 0, 0);
      pdf.setFontSize(10);
      pdf.setFont(undefined, 'normal');

      const notesLines = pdf.splitTextToSize(task.Notes, pageWidth - 40);
      pdf.text(notesLines, 20, yPosition);
      yPosition += (notesLines.length * 5) + 10;
    }

    // Footer on last page
    const pageCount = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      
      // Page number
      pdf.setFontSize(8);
      pdf.setTextColor(150, 150, 150);
      pdf.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
      
      // Confidential footer
      pdf.text('Confidential - Gliggo Internal Use Only', pageWidth / 2, pageHeight - 5, { align: 'center' });
    }

    // Generate filename and save
    const fileName = `Task_Report_${task.SINO || task.id}_${new Date().toISOString().split('T')[0]}.pdf`;
    pdf.save(fileName);

  } catch (error) {
    console.error('PDF generation failed:', error);
    alert('Failed to generate PDF report. Please try again.');
  } finally {
    // Restore button state
    downloadBtn.innerHTML = originalHtml;
    downloadBtn.disabled = false;
  }
}

// Helper function to format date for datetime-local input
function formatDateTimeLocal(date) {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  const hours = String(d.getHours()).padStart(2, '0');
  const minutes = String(d.getMinutes()).padStart(2, '0');
  
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}

// Apply filters and pagination
function applyFilters() {
  const companySearch = searchCompany.value.toLowerCase();
  const ownerSearch = searchOwner.value.toLowerCase();
  const statusValue = statusFilter.value;
  const dateFilterValue = dateFilter.value;
  const customStart = customDateStart.value;
  const customEnd = customDateEnd.value;

  filteredTasks = allTasks.filter(task => {
    // Company name filter
    const companyMatch = !companySearch || 
      (task['Existing Company Name'] && task['Existing Company Name'].toLowerCase().includes(companySearch));
    
    // Owner filter
    const ownerMatch = !ownerSearch || 
      (task.Owner && task.Owner.toLowerCase().includes(ownerSearch));
    
    // Status filter
    const statusMatch = !statusValue || task.Status === statusValue;
    
    // Date filter
    let dateMatch = true;
    if (dateFilterValue && task['Due date']) {
      const taskDate = new Date(task['Due date']);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      switch (dateFilterValue) {
        case 'today':
          const taskToday = new Date(taskDate);
          taskToday.setHours(0, 0, 0, 0);
          dateMatch = taskToday.getTime() === today.getTime();
          break;
        case 'yesterday':
          const yesterday = new Date(today);
          yesterday.setDate(yesterday.getDate() - 1);
          const taskYesterday = new Date(taskDate);
          taskYesterday.setHours(0, 0, 0, 0);
          dateMatch = taskYesterday.getTime() === yesterday.getTime();
          break;
        case 'thisWeek':
          const startOfWeek = new Date(today);
          startOfWeek.setDate(today.getDate() - today.getDay());
          dateMatch = taskDate >= startOfWeek;
          break;
        case 'lastWeek':
          const startOfLastWeek = new Date(today);
          startOfLastWeek.setDate(today.getDate() - today.getDay() - 7);
          const endOfLastWeek = new Date(startOfLastWeek);
          endOfLastWeek.setDate(startOfLastWeek.getDate() + 6);
          dateMatch = taskDate >= startOfLastWeek && taskDate <= endOfLastWeek;
          break;
        case 'thisMonth':
          dateMatch = taskDate.getMonth() === today.getMonth() && 
                     taskDate.getFullYear() === today.getFullYear();
          break;
        case 'lastMonth':
          const lastMonth = today.getMonth() === 0 ? 11 : today.getMonth() - 1;
          const lastMonthYear = today.getMonth() === 0 ? today.getFullYear() - 1 : today.getFullYear();
          dateMatch = taskDate.getMonth() === lastMonth && 
                     taskDate.getFullYear() === lastMonthYear;
          break;
        case 'custom':
          if (customStart && customEnd) {
            dateMatch = taskDate >= new Date(customStart) && 
                       taskDate <= new Date(customEnd);
          }
          break;
      }
    }
    
    return companyMatch && ownerMatch && statusMatch && dateMatch;
  });

  currentPage = 1;
  renderTablePage(currentPage, filteredTasks);
  renderPagination();
}

// Render pagination controls
function renderPagination() {
  const totalPages = Math.ceil(filteredTasks.length / rowsPerPage);
  paginationDiv.innerHTML = '';

  if (totalPages <= 1) return;

  // Previous button
  const prevBtn = document.createElement('button');
  prevBtn.textContent = '←';
  prevBtn.disabled = currentPage === 1;
  prevBtn.addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      renderTablePage(currentPage, filteredTasks);
      renderPagination();
    }
  });
  paginationDiv.appendChild(prevBtn);

  // Page numbers
  for (let i = 1; i <= totalPages; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.textContent = i;
    pageBtn.classList.toggle('active', i === currentPage);
    pageBtn.addEventListener('click', () => {
      currentPage = i;
      renderTablePage(currentPage, filteredTasks);
      renderPagination();
    });
    paginationDiv.appendChild(pageBtn);
  }

  // Next button
  const nextBtn = document.createElement('button');
  nextBtn.textContent = '→';
  nextBtn.disabled = currentPage === totalPages;
  nextBtn.addEventListener('click', () => {
    if (currentPage < totalPages) {
      currentPage++;
      renderTablePage(currentPage, filteredTasks);
      renderPagination();
    }
  });
  paginationDiv.appendChild(nextBtn);
}

// Populate dropdowns with existing people
async function populateDropdowns() {
  try {
    const snapshot = await db.collection('people').get();
    const people = [];
    snapshot.forEach(doc => {
      people.push({ id: doc.id, ...doc.data() });
    });

    // Clear existing options (except first placeholder)
    ownerSelect.innerHTML = '<option value="">Select Owner</option>';
    assignedBySelect.innerHTML = '<option value="">Select Assigned By</option>';

    // Populate both dropdowns
    people.forEach(person => {
      const option1 = document.createElement('option');
      option1.value = person.name;
      option1.textContent = person.name;
      ownerSelect.appendChild(option1);

      const option2 = document.createElement('option');
      option2.value = person.name;
      option2.textContent = person.name;
      assignedBySelect.appendChild(option2);
    });

    // Add "Add New Person" option
    const addOwnerOption = document.createElement('option');
    addOwnerOption.value = 'add_new_person_owner';
    addOwnerOption.textContent = '+ Add New Person';
    ownerSelect.appendChild(addOwnerOption);

    const addAssignedByOption = document.createElement('option');
    addAssignedByOption.value = 'add_new_person_assignedBy';
    addAssignedByOption.textContent = '+ Add New Person';
    assignedBySelect.appendChild(addAssignedByOption);

  } catch (error) {
    console.error('Error loading people:', error);
  }
}

// Event Listeners
searchCompany.addEventListener('input', applyFilters);
searchOwner.addEventListener('input', applyFilters);
statusFilter.addEventListener('change', applyFilters);
dateFilter.addEventListener('change', function() {
  customDateStart.style.display = this.value === 'custom' ? 'inline-block' : 'none';
  customDateEnd.style.display = this.value === 'custom' ? 'inline-block' : 'none';
  applyFilters();
});
customDateStart.addEventListener('change', applyFilters);
customDateEnd.addEventListener('change', applyFilters);

createTaskBtn.addEventListener('click', () => {
  editingTaskId = null;
  modalTitle.textContent = 'Create New Task';
  taskForm.reset();
  
  // Hide time editing section for new tasks
  timeEditSection.style.display = 'none';
  
  populateDropdowns();
  taskModal.style.display = 'flex';
});

// Handle dropdown change for "Add New Person"
ownerSelect.addEventListener('change', function() {
  if (this.value === 'add_new_person_owner') {
    currentPersonType = 'owner';
    addPersonModal.style.display = 'flex';
    this.value = ''; // Reset selection
  }
});

assignedBySelect.addEventListener('change', function() {
  if (this.value === 'add_new_person_assignedBy') {
    currentPersonType = 'assignedBy';
    addPersonModal.style.display = 'flex';
    this.value = ''; // Reset selection
  }
});

// Handle form submission for adding new person
addPersonForm.addEventListener('submit', async e => {
  e.preventDefault();
  const name = newPersonName.value.trim();
  const type = personType.value;

  if (!name) return;

  try {
    await db.collection('people').add({
      name: name,
      type: type,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });

    // Refresh dropdowns
    await populateDropdowns();
    
    // Auto-select the newly added person in the appropriate dropdown
    if (currentPersonType === 'owner') {
      ownerSelect.value = name;
    } else if (currentPersonType === 'assignedBy') {
      assignedBySelect.value = name;
    }

    addPersonModal.style.display = 'none';
    addPersonForm.reset();
    
  } catch (error) {
    console.error('Error adding person:', error);
    alert('Failed to add person');
  }
});

// Handle main task form submission
taskForm.addEventListener('submit', async e => {
  e.preventDefault();
  const formData = new FormData(taskForm);
  const taskData = {
    'Existing Company Name': formData.get('company'),
    'TYPE OF WORK': formData.get('typeOfWork'),
    'ACCOUNT TYPE': formData.get('accountType'),
    'Accounts / Cards': formData.get('accountsCards'),
    'Task': formData.get('task'),
    'WORK FOR': formData.get('workFor'),
    'PERIOD': formData.get('period'),
    'Due date': formData.get('dueDate'),
    'Owner': formData.get('owner'),
    'Assigned By': formData.get('assignedBy'),
    'Notes': formData.get('notes'),
    'Status': 'Not Started', // Default status
    'Created At': firebase.firestore.FieldValue.serverTimestamp()
  };

  // For editing, include time information
  if (editingTaskId) {
    const timeStart = document.getElementById('timeStartInput').value;
    const timeEnd = document.getElementById('timeEndInput').value;
    const remarks = document.getElementById('remarksInput').value;

    if (timeStart) {
      taskData.timeStart = new Date(timeStart);
    }
    if (timeEnd) {
      taskData.timeEnd = new Date(timeEnd);
    }
    if (remarks) {
      taskData.Remarks = remarks;
    }
  }

  try {
    if (editingTaskId) {
      // Update existing task
      await db.collection('tasks').doc(editingTaskId).update(taskData);
      alert('Task updated successfully!');
    } else {
      // Create new task - generate SINO
      const lastTask = allTasks[allTasks.length - 1];
      let nextSinoNumber = 1;
      
      if (lastTask && lastTask.SINO) {
        const lastNumber = parseInt(lastTask.SINO.replace('GL', '')) || 0;
        nextSinoNumber = lastNumber + 1;
      }
      
      taskData.SINO = `GL${nextSinoNumber.toString().padStart(3, '0')}`;
      await db.collection('tasks').add(taskData);
      alert('Task created successfully!');
    }

    taskModal.style.display = 'none';
    loadTasks(); // Reload tasks to reflect changes
  } catch (error) {
    console.error('Error saving task:', error);
    alert('Failed to save task');
  }
});

// Handle workFor selection to show/hide period input
const workForSelect = document.getElementById('workForSelect');
const periodInput = document.getElementById('periodInput');

workForSelect.addEventListener('change', function() {
  periodInput.style.display = this.value === 'Custom' ? 'block' : 'none';
  if (this.value !== 'Custom') {
    periodInput.value = '';
  }
});

// CSV Upload functionality
uploadCSVBtn.addEventListener('click', () => csvUpload.click());

csvUpload.addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    complete: async results => {
      if (results.errors.length) {
        alert('CSV parsing errors: ' + results.errors.map(e => e.message).join(', '));
        return;
      }

      let successCount = 0;
      let errorCount = 0;

      for (const row of results.data) {
        try {
          // Generate SINO for new tasks
          const lastTask = allTasks[allTasks.length - 1];
          let nextSinoNumber = 1;
          
          if (lastTask && lastTask.SINO) {
            const lastNumber = parseInt(lastTask.SINO.replace('GL', '')) || 0;
            nextSinoNumber = lastNumber + 1;
          }
          
          const taskData = {
            SINO: `GL${nextSinoNumber.toString().padStart(3, '0')}`,
            'Existing Company Name': row['Existing Company Name'] || '',
            'TYPE OF WORK': row['TYPE OF WORK'] || '',
            'ACCOUNT TYPE': row['ACCOUNT TYPE'] || '',
            'Accounts / Cards': row['Accounts / Cards'] || '',
            'Task': row.Task || '',
            'WORK FOR': row['WORK FOR'] || '',
            'PERIOD': row.PERIOD || '',
            'Due date': row['Due date'] || '',
            'Owner': row.Owner || '',
            'Assigned By': row['Assigned By'] || '',
            'Notes': row.Notes || '',
            'Status': row.Status || 'Not Started',
            'Created At': firebase.firestore.FieldValue.serverTimestamp()
          };

          await db.collection('tasks').add(taskData);
          successCount++;
        } catch (error) {
          console.error('Error importing task:', error);
          errorCount++;
        }
      }

      alert(`CSV import completed: ${successCount} successful, ${errorCount} failed`);
      csvUpload.value = ''; // Reset file input
      loadTasks(); // Reload tasks
    }
  });
});

// Download CSV template
downloadTemplateBtn.addEventListener('click', () => {
  const headers = [
    'Existing Company Name',
    'TYPE OF WORK', 
    'ACCOUNT TYPE',
    'Accounts / Cards',
    'Task',
    'WORK FOR',
    'PERIOD',
    'Due date',
    'Owner',
    'Assigned By',
    'Notes',
    'Status'
  ];

  const csvContent = headers.join(',') + '\n';
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'task_template.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
  loadTasks();
  populateDropdowns();
});
</script>
</body>
</html>
      
      