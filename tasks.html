<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tasks Overview</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Reset & base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #6b73ff 0%, #000dff 100%);
      margin: 40px 0;
      color: #444;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container {
      background: white;
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow:
        0 4px 30px rgba(0, 0, 0, 0.25),
        0 10px 20px rgba(50, 50, 93, 0.1);
      width: 95%;
      max-width: 1400px;
    }

    h1 {
      text-align: center;
      margin-bottom: 25px;
      font-weight: 700;
      color: #222;
      text-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    /* Filters container */
    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 25px;
      justify-content: center;
      align-items: center;
    }

    .filters input, .filters select {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-size: 14px;
      min-width: 150px;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
      transition: border-color 0.3s ease;
    }

    .filters input:focus, .filters select:focus {
      outline: none;
      border-color: #3a42f4;
      box-shadow: 0 0 8px rgba(58, 66, 244, 0.5);
    }

    /* Table styling */
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      background: #fefefe;
    }

    thead tr {
      background: linear-gradient(90deg, #3a42f4, #6b73ff);
      color: white;
      font-weight: 700;
      text-transform: uppercase;
      box-shadow: inset 0 -4px 10px rgba(0,0,0,0.2);
    }

    thead th {
      padding: 12px 16px;
      user-select: none;
      border-right: 1px solid rgba(255,255,255,0.2);
    }

    thead th:last-child {
      border-right: none;
    }

    tbody tr {
      transition: background-color 0.25s ease, box-shadow 0.3s ease;
      cursor: default;
    }

    tbody tr:nth-child(odd) {
      background-color: #fafaff;
    }

    tbody tr:hover {
      background-color: #e3e5ff;
      box-shadow: 0 6px 15px rgba(58, 66, 244, 0.25);
    }

    tbody td {
      padding: 14px 16px;
      border-right: 1px solid #ddd;
      vertical-align: middle;
      font-size: 14px;
      color: #333;
      max-width: 180px;
      word-break: break-word;
    }

    tbody td:last-child {
      border-right: none;
    }

    /* Edit/Delete button styles */
    .action-btn {
      padding: 6px 14px;
      margin: 0 4px;
      border-radius: 8px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
    }

    .edit-btn {
      background-color: #4caf50;
      color: white;
    }

    .edit-btn:hover {
      background-color: #3b8e40;
      transform: translateY(-2px);
    }

    .delete-btn {
      background-color: #f44336;
      color: white;
    }

    .delete-btn:hover {
      background-color: #b83227;
      transform: translateY(-2px);
    }
    
    .start-btn {
      background-color: #2196f3;
      color: white;
    }

    .start-btn:hover {
      background-color: #0b7dda;
      transform: translateY(-2px);
    }
    
    .complete-btn {
      background-color: #ff9800;
      color: white;
    }

    .complete-btn:hover {
      background-color: #e68a00;
      transform: translateY(-2px);
    }

    /* Pagination styles */
    .pagination {
      margin-top: 20px;
      text-align: center;
    }

    .pagination button {
      margin: 0 6px;
      padding: 8px 16px;
      border-radius: 10px;
      border: none;
      background-color: #3a42f4;
      color: white;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(58, 66, 244, 0.4);
      transition: all 0.3s ease;
    }

    .pagination button:disabled {
      background-color: #999;
      cursor: default;
      box-shadow: none;
    }

    .pagination button:hover:not(:disabled) {
      background-color: #2a31d9;
      transform: translateY(-2px);
    }

    /* Added for detail row visibility */
    .details-row td {
      background-color: #f9f9f9;
      padding: 16px;
      border-top: 1px solid #ccc;
    }

    .details-box {
      background: #eef1ff;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 14px;
      line-height: 1.6;
      color: #333;
    }

    /* Optional animation for detail reveal */
    .details-row {
      transition: all 0.3s ease;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .top-button {
      display: inline-block;
      padding: 10px 20px;
      text-decoration: none;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      border-radius: 8px;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 123, 255, 0.3);
    }

    .top-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 123, 255, 0.4);
    }

    #createTaskBtn, #uploadCSVBtn, #downloadTemplateBtn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 30px;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      z-index: 999;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
    }
    
    #createTaskBtn:hover, #uploadCSVBtn:hover, #downloadTemplateBtn:hover {
      transform: translateY(-5px) scale(1.05);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
    }
    
    #uploadCSVBtn {
      bottom: 100px;
      background: linear-gradient(135deg, #007bff, #6610f2);
      font-size: 20px;
    }
    
    #downloadTemplateBtn {
      bottom: 170px;
      background: linear-gradient(135deg, #6f42c1, #e83e8c);
      font-size: 20px;
    }

    /* Modal container */
    #taskModal, #addPersonModal {
      background: rgba(0, 0, 0, 0.6);
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    /* Modal box */
    #taskModal > div, #addPersonModal > div {
      background: linear-gradient(145deg, #ffffff, #f0f0f0);
      padding: 30px 25px;
      border-radius: 20px;
      width: 95%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      font-family: 'Segoe UI', sans-serif;
      position: relative;
    }

    /* Modal heading */
    #taskModal h3, #addPersonModal h3 {
      margin-top: 0;
      margin-bottom: 20px;
      color: #333;
      font-size: 24px;
      text-align: center;
      background: linear-gradient(135deg, #3a42f4, #6b73ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }

    /* Inputs, selects, textarea */
    #taskModal input,
    #taskModal select,
    #taskModal textarea,
    #addPersonModal input,
    #addPersonModal select {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      font-size: 15px;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f8f9fa;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }

    #taskModal input:focus,
    #taskModal select:focus,
    #taskModal textarea:focus,
    #addPersonModal input:focus,
    #addPersonModal select:focus {
      border-color: #3a42f4;
      outline: none;
      background: white;
      box-shadow: 0 0 0 3px rgba(58, 66, 244, 0.2);
    }

    /* Buttons */
    #taskModal button[type="submit"],
    #addPersonModal button[type="submit"] {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: #fff;
      font-weight: bold;
      padding: 12px 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      width: 48%;
      margin-right: 4%;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(40, 167, 69, 0.3);
    }

    #taskModal button[type="submit"]:hover,
    #addPersonModal button[type="submit"]:hover {
      background: linear-gradient(135deg, #218838, #1e9e6e);
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(40, 167, 69, 0.4);
    }

    #taskModal button[type="button"],
    #addPersonModal button[type="button"] {
      background: linear-gradient(135deg, #6c757d, #5a6268);
      color: #fff;
      padding: 12px 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      width: 48%;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(108, 117, 125, 0.3);
    }

    #taskModal button[type="button"]:hover,
    #addPersonModal button[type="button"]:hover {
      background: linear-gradient(135deg, #5a6268, #495057);
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(108, 117, 125, 0.4);
    }
    
    /* Time editing section in modal */
    .time-edit-section {
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      border: 1px solid #bbdefb;
      display: none;
    }
    
    .time-edit-section h4 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #1565c0;
      font-size: 18px;
      display: flex;
      align-items: center;
    }
    
    .time-edit-section h4 i {
      margin-right: 10px;
    }
    
    .time-input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .time-input-group input {
      flex: 1;
      margin-bottom: 0;
    }
    
    /* Status badges */
    .status-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .status-pending {
      background: linear-gradient(135deg, #ff9800, #f57c00);
      color: white;
    }
    
    .status-complete {
      background: linear-gradient(135deg, #4caf50, #2e7d32);
      color: white;
    }
    
    .status-progress {
      background: linear-gradient(135deg, #2196f3, #0d47a1);
      color: white;
    }
    
    /* Date filter section */
    .date-filter-section {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 15px;
      padding: 15px;
      background: linear-gradient(135deg, #e8eaf6, #c5cae9);
      border-radius: 12px;
    }
    
    .date-filter-section select, 
    .date-filter-section input {
      flex: 1;
      min-width: 120px;
    }
    
    /* Dropdown with "Add New" option */
    select option.add-new {
      background-color: #e9ecef;
      color: #495057;
      font-weight: bold;
      border-top: 1px solid #dee2e6;
    }
    
    /* Timer display */
    .timer-display {
      font-family: monospace;
      font-size: 16px;
      font-weight: bold;
      background: #333;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      display: inline-block;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    /* Form sections */
    .form-section {
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 4px solid #3a42f4;
    }
    
    .form-section h4 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #3a42f4;
      font-size: 16px;
      display: flex;
      align-items: center;
    }
    
    .form-section h4 i {
      margin-right: 10px;
    }
    
    /* Responsive tweaks */
    @media (max-width: 768px) {
      .filters {
        flex-direction: column;
        align-items: stretch;
      }

      .filters select,
      .filters input {
        min-width: 100%;
      }

      .container {
        padding: 20px 25px;
      }

      tbody td {
        font-size: 12px;
      }
      
      .date-filter-section {
        flex-direction: column;
        align-items: stretch;
      }
      
      .time-input-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="top-bar">
    <a href="Home.html" class="top-button">Home</a>
    <a href="Current task.html" class="top-button">Current Works</a>
  </div>

  <h1>Tasks Overview</h1>

  <div class="filters">
    <input type="text" id="searchCompany" placeholder="Search Company Name" />
    <input type="text" id="searchOwner" placeholder="Search Owner" />
    <select id="statusFilter">
      <option value="">All Status</option>
      <option value="Not Started">Not Started</option>
      <option value="In Progress">In Progress</option>
      <option value="Complete">Completed</option>
    </select>
    
    <div class="date-filter-section">
      <select id="dateFilter">
        <option value="">All Dates</option>
        <option value="today">Today</option>
        <option value="yesterday">Yesterday</option>
        <option value="thisWeek">This Week</option>
        <option value="lastWeek">Last Week</option>
        <option value="thisMonth">This Month</option>
        <option value="lastMonth">Last Month</option>
        <option value="custom">Custom Range</option>
      </select>
      
      <input type="date" id="customDateStart" style="display: none;" placeholder="Start Date">
      <input type="date" id="customDateEnd" style="display: none;" placeholder="End Date">
    </div>
  </div>

  <table id="tasksTable" class="overview-table">
    <thead>
      <tr>
        <th>SINO</th>
        <th>Existing Company Name</th>
        <th>TYPE OF WORK</th>
        <th>Status</th>
        <th>Owner</th>
        <th>Due Date</th>
      </tr>
    </thead>
    <tbody>
      <!-- Rows appended by JS -->
    </tbody>
  </table>

  <div id="paginationControls" class="pagination" style="margin-top: 20px;"></div>

  <div id="taskDetails" class="task-details" style="display:none;">
    <h2>Task Details</h2>
    <table id="detailsTable">
      <!-- Details rows generated by JS -->
    </table>
  </div>
</div>

<!-- Modal for Creating/Editing Task -->
<div id="taskModal" style="display:none;">
  <div>
    <h3 id="modalTitle">Create New Task</h3>
    <form id="taskForm">
      <div class="form-section">
        <h4><i class="fas fa-building"></i> Company Information</h4>
        <input list="companyList" name="company" id="companyInput" placeholder="Company Name" required />
        <datalist id="companyList"></datalist>

        <input list="workTypeList" name="typeOfWork" id="typeOfWorkInput" placeholder="TYPE OF WORK" required />
        <datalist id="workTypeList"></datalist>

        <select name="accountType" id="accountTypeSelect">
          <option value="">Select ACCOUNT TYPE</option>
          <option value="Saving Acc">Saving Acc</option>
          <option value="Chequing Acc">Chequing Acc</option>
          <option value="Loan Acc">Loan Acc</option>
          <option value="Credit Card">Credit Card</option>
          <option value="Other">Other</option>
        </select>

        <input type="text" name="accountsCards" id="accountsCards" placeholder="Accounts / Cards" list="accountsCardsList"/>
        <datalist id="accountsCardsList"></datalist>
      </div>

      <div class="form-section">
        <h4><i class="fas fa-tasks"></i> Task Details</h4>
        <input type="text" name="task" placeholder="Task" />

        <select name="workFor" id="workForSelect">
          <option value="">Select WORK FOR</option>
          <option value="Yearly">Yearly</option>
          <option value="Monthly">Monthly</option>
          <option value="Weekly">Weekly</option>
          <option value="Daily">Daily</option>
          <option value="Custom">Custom</option>
        </select>

        <input type="text" name="period" id="periodInput" placeholder="PERIOD" style="display:none;" />

        <input type="date" name="dueDate" required />
      </div>

      <div class="form-section">
        <h4><i class="fas fa-users"></i> Assignment</h4>
        <select name="owner" id="ownerSelect" required>
          <option value="">Select Owner</option>
        </select>

        <select name="assignedBy" id="assignedBySelect" required>
          <option value="">Select Assigned By</option>
        </select>
      </div>

      <div class="form-section">
        <h4><i class="fas fa-sticky-note"></i> Additional Information</h4>
        <textarea name="notes" placeholder="Notes" rows="3"></textarea>
      </div>
      
      <!-- Time Editing Section - Hidden by default, shown only in edit mode -->
      <div class="time-edit-section" id="timeEditSection">
        <h4><i class="fas fa-clock"></i> Time Tracking</h4>
        <div class="time-input-group">
          <input type="datetime-local" id="timeStartInput" placeholder="Start Time">
          <input type="datetime-local" id="timeEndInput" placeholder="End Time">
        </div>
        <div class="time-input-group">
          <input type="text" id="totalWorkHours" placeholder="Total Work Hours" readonly>
          <input type="text" id="totalPauseHours" placeholder="Total Pause Hours" readonly>
        </div>
        <input type="text" id="remarksInput" placeholder="Remarks">
      </div>

      <div style="display: flex; justify-content: space-between; margin-top: 20px;">
        <button type="submit">Save Task</button>
        <button type="button" onclick="document.getElementById('taskModal').style.display='none'">Cancel</button>
      </div>
    </form> 
  </div>
</div>

<!-- Modal for Adding New Person -->
<div id="addPersonModal" style="display:none;">
  <div>
    <h3 id="addPersonModalTitle">Add New Person</h3>
    <form id="addPersonForm">
      <input type="text" id="newPersonName" placeholder="Enter Name" required />
      <select id="personType">
        <option value="owner">Owner</option>
        <option value="assignedBy">Assigned By</option>
      </select><br/>
      <button type="submit">Add Person</button>
      <button type="button" onclick="document.getElementById('addPersonModal').style.display='none'">Cancel</button>
    </form>
  </div>
</div>

<!-- Floating Buttons -->
<button id="createTaskBtn">+</button>
<input type="file" id="csvUpload" style="display:none" accept=".csv" />
<button id="uploadCSVBtn"><i class="fas fa-upload"></i></button>
<button id="downloadTemplateBtn"><i class="fas fa-download"></i></button>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<!-- PapaParse CSV Parser -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<script>
let editingTaskId = null;
let currentPersonType = null;
let activeTimers = {}; // Track active timers for tasks

// Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyDYhLNuJKj2ucwGimfddTfpTb32Y0c-bXg",
  authDomain: "mytask-96a79.firebaseapp.com",
  databaseURL: "https://mytask-96a79-default-rtdb.firebaseio.com",
  projectId: "mytask-96a79",
  storageBucket: "mytask-96a79.firebasestorage.app",
  messagingSenderId: "963509757773",
  appId: "1:963509757773:web:d9c81a108f5873702eb904",
  measurementId: "G-L9C1LTCZRN"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// DOM Elements
const taskTableBody = document.querySelector('#tasksTable tbody');
const paginationDiv = document.getElementById('paginationControls');
const searchCompany = document.getElementById('searchCompany');
const searchOwner = document.getElementById('searchOwner');
const statusFilter = document.getElementById('statusFilter');
const dateFilter = document.getElementById('dateFilter');
const customDateStart = document.getElementById('customDateStart');
const customDateEnd = document.getElementById('customDateEnd');
const createTaskBtn = document.getElementById('createTaskBtn');
const taskModal = document.getElementById('taskModal');
const taskForm = document.getElementById('taskForm');
const ownerSelect = document.getElementById('ownerSelect');
const assignedBySelect = document.getElementById('assignedBySelect');
const companyInput = taskForm.elements['company'];
const modalTitle = document.getElementById('modalTitle');
const uploadCSVBtn = document.getElementById('uploadCSVBtn');
const csvUpload = document.getElementById('csvUpload');
const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
const addPersonModal = document.getElementById('addPersonModal');
const addPersonForm = document.getElementById('addPersonForm');
const newPersonName = document.getElementById('newPersonName');
const personType = document.getElementById('personType');
const timeEditSection = document.getElementById('timeEditSection');

const rowsPerPage = 10;
let currentPage = 1;
let allTasks = [];
let filteredTasks = [];

// Load tasks from Firestore
async function loadTasks() {
  try {
    const snapshot = await db.collection('tasks').get();
    allTasks = []; // reset on reload
    snapshot.forEach(doc => {
      allTasks.push({ id: doc.id, ...doc.data() });
    });

    // Sort ascending by numeric part of SINO
    allTasks.sort((a, b) => {
      const getNumber = sino => {
        if (!sino) return 0;
        const match = sino.match(/(\d+)$/);
        return match ? parseInt(match[1], 10) : 0;
      };
      return getNumber(a.SINO) - getNumber(b.SINO);
    });

    // Start timers for any in-progress tasks
    allTasks
      .filter(task => task.Status === "In Progress" && task.taskStart)
      .forEach(task => {
        startTimerForTask(task.id);
      });
    
    populateCompanyList();
    applyFilters(); // Initial render with sorting applied
  } catch (error) {
    console.error(error);
  }
}

function populateCompanyList() {
  const companyList = document.getElementById('companyList');
  companyList.innerHTML = ''; // Clear previous options

  const companiesSet = new Set();

  allTasks.forEach(task => {
    const company = task['Existing Company Name'];
    if (company) {
      companiesSet.add(company);
    }
  });

  companiesSet.forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    companyList.appendChild(option);
  });
}

// Render a specific page
function renderTablePage(page, tasks) {
  taskTableBody.innerHTML = '';
  const start = (page - 1) * rowsPerPage;
  const pageTasks = tasks.slice(start, start + rowsPerPage);

  pageTasks.forEach(task => {
    const tr = document.createElement('tr');
    tr.classList.add('task-row');
    
    // Create status badge
    let statusClass = '';
    if (task.Status === 'Not Started') statusClass = 'status-pending';
    else if (task.Status === 'Complete') statusClass = 'status-complete';
    else if (task.Status === 'In Progress') statusClass = 'status-progress';
    
    tr.innerHTML = `
      <td>${task.SINO || ''}</td>
      <td>${task['Existing Company Name'] || ''}</td>
      <td>${task['TYPE OF WORK'] || ''}</td>
      <td><span class="status-badge ${statusClass}">${task.Status || ''}</span></td>
      <td>${task.Owner || ''}</td>
      <td>${task['Due date'] || ''}</td>
    `;

    const detailsTr = document.createElement('tr');
    detailsTr.classList.add('details-row');
    detailsTr.style.display = 'none';
    
    // Show time information for completed and in-progress tasks
    let timeInfoHtml = '';
    if (task.Status === 'Complete' || task.Status === 'In Progress') {
      timeInfoHtml = `
        <strong>Time Started:</strong> ${formatTimestamp(task.taskStart)}<br/>
        ${task.Status === 'Complete' ? `<strong>Time End:</strong> ${formatTimestamp(task.taskEnd)}<br/>` : ''}
        <strong>Total Work Hours:</strong> ${task.TotalWorkHours || ''}<br/>
        <strong>Total Pause Hours:</strong> ${task.TotalPauseHours || ''}<br/>
        <strong>Remarks:</strong> ${task.Remarks || ''}<br/><br/>
      `;
    }
    
    // Add timer display for in-progress tasks
    let timerHtml = '';
    if (task.Status === 'In Progress') {
      timerHtml = `
        <div style="margin: 10px 0;">
          <strong>Elapsed Time:</strong> 
          <span class="timer-display" id="timer-${task.id}">${calculateElapsedTime(task.taskStart)}</span>
        </div>
      `;
    }
    
    // Action buttons based on status
    let actionButtons = '';
    if (task.Status === 'Not Started') {
      actionButtons = `
        <button class="start-btn action-btn" data-id="${task.id}">Start Task</button>
        <button class="edit-btn action-btn" data-id="${task.id}">Edit</button>
        <button class="delete-btn action-btn" data-id="${task.id}">Delete</button>
      `;
    } else if (task.Status === 'In Progress') {
      actionButtons = `
        <button class="complete-btn action-btn" data-id="${task.id}">Complete Task</button>
        <button class="edit-btn action-btn" data-id="${task.id}">Edit</button>
        <button class="delete-btn action-btn" data-id="${task.id}">Delete</button>
      `;
    } else {
      actionButtons = `
        <button class="edit-btn action-btn" data-id="${task.id}">Edit</button>
        <button class="delete-btn action-btn" data-id="${task.id}">Delete</button>
      `;
    }
    
    detailsTr.innerHTML = `
      <td colspan="6">
        <div class="details-box">
          <strong>ACCOUNT TYPE:</strong> ${task['ACCOUNT TYPE'] || ''}<br/>
          <strong>Accounts / Cards:</strong> ${task['Accounts / Cards'] || ''}<br/>
          <strong>Task:</strong> ${task.Task || ''}<br/>
          <strong>WORK FOR:</strong> ${task['WORK FOR'] || ''}<br/>
          <strong>PERIOD:</strong> ${task.PERIOD || ''}<br/>
          <strong>Due Date:</strong> ${task['Due date'] || ''}<br/>
          <strong>Assigned By:</strong> ${task['Assigned By'] || ''}<br/>
          <strong>Notes:</strong> ${task.Notes || ''}<br/>
          ${timeInfoHtml}
          ${timerHtml}
          ${actionButtons}
        </div>
      </td>
    `;

    tr.addEventListener('click', () => {
      detailsTr.style.display = detailsTr.style.display === 'none' ? 'table-row' : 'none';
    });

    taskTableBody.appendChild(tr);
    taskTableBody.appendChild(detailsTr);
  });

  attachRowEventListeners();
}

function formatTimestamp(ts) {
  if (!ts) return '';
  if (typeof ts.toDate === 'function') {
    return ts.toDate().toLocaleString();
  }
  if (ts instanceof Date) {
    return ts.toLocaleString();
  }
  return '';
}

function calculateElapsedTime(startTime) {
  if (!startTime) return '00:00:00';
  
  const start = startTime.toDate ? startTime.toDate() : new Date(startTime);
  const now = new Date();
  const diffMs = now - start;
  
  const hours = Math.floor(diffMs / (1000 * 60 * 60));
  const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
  
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

function startTimerForTask(taskId) {
  // Clear any existing timer for this task
  if (activeTimers[taskId]) {
    clearInterval(activeTimers[taskId]);
  }
  
  // Start a new timer
  activeTimers[taskId] = setInterval(() => {
    const timerElement = document.getElementById(`timer-${taskId}`);
    if (timerElement) {
      const task = allTasks.find(t => t.id === taskId);
      if (task && task.taskStart) {
        timerElement.textContent = calculateElapsedTime(task.taskStart);
      }
    }
  }, 1000);
}

// Start a task
async function startTask(taskId) {
  const task = allTasks.find(t => t.id === taskId);
  if (!task) return alert('Task not found');
  
  try {
    const now = firebase.firestore.Timestamp.now();
    await db.collection('tasks').doc(taskId).update({
      Status: "In Progress",
      taskStart: now,
      TimeStarted: formatTimestamp(now)
    });
    
    // Start timer for this task
    startTimerForTask(taskId);
    
    alert('Task started!');
    loadTasks(); // Reload to reflect changes
  } catch (err) {
    console.error(err);
    alert('Failed to start task');
  }
}

// Complete a task
async function completeTask(taskId) {
  const task = allTasks.find(t => t.id === taskId);
  if (!task) return alert('Task not found');
  
  try {
    const now = firebase.firestore.Timestamp.now();
    const taskRef = db.collection('tasks').doc(taskId);
    
    // Stop timer for this task
    if (activeTimers[taskId]) {
      clearInterval(activeTimers[taskId]);
      delete activeTimers[taskId];
    }
    
    // Calculate work hours
    const startTime = task.taskStart;
    const endTime = now;
    
    const workHours = calculateTimeDifference(startTime, endTime);
    const totalWorkHours = `${workHours.hours}h ${workHours.minutes}m`;
    
    await taskRef.update({
      Status: "Complete",
      taskEnd: now,
      TimeEnd: formatTimestamp(now),
      TotalWorkHours: totalWorkHours
    });
    
    alert('Task completed!');
    loadTasks(); // Reload to reflect changes
  } catch (err) {
    console.error(err);
    alert('Failed to complete task');
  }
}

// Attach edit/delete/complete button events
function attachRowEventListeners() {
  document.querySelectorAll('.delete-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.dataset.id;
      if (confirm('Delete this task?')) {
        try {
          // Stop timer if running
          if (activeTimers[id]) {
            clearInterval(activeTimers[id]);
            delete activeTimers[id];
          }
          
          await db.collection('tasks').doc(id).delete();
          alert('Deleted');
          loadTasks();
        } catch (err) {
          console.error(err);
          alert('Delete failed');
        }
      }
    });
  });

  document.querySelectorAll('.edit-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.dataset.id;
      const task = allTasks.find(t => t.id === id);
      if (!task) return alert('Task not found');

      editingTaskId = id; // Track the task being edited
      modalTitle.textContent = 'Edit Task';
      populateDropdowns(); // Ensure dropdowns are filled
      taskForm.reset(); // Clear previous data

      // Show time editing section for existing tasks
      timeEditSection.style.display = 'block';

      // Populate form fields
      taskForm.elements['company'].value = task['Existing Company Name'] || '';
      taskForm.elements['typeOfWork'].value = task['TYPE OF WORK'] || '';
      taskForm.elements['accountType'].value = task['ACCOUNT TYPE'] || '';
      taskForm.elements['accountsCards'].value = task['Accounts / Cards'] || '';
      taskForm.elements['task'].value = task.Task || '';
      taskForm.elements['owner'].value = task.Owner || '';
      taskForm.elements['workFor'].value = task['WORK FOR'] || '';
      taskForm.elements['period'].value = task.PERIOD || '';
      taskForm.elements['dueDate'].value = task['Due date'] || '';
      taskForm.elements['assignedBy'].value = task['Assigned By'] || '';
      taskForm.elements['notes'].value = task.Notes || '';
      
      // Populate time fields
      document.getElementById('timeStartInput').value = task.taskStart ? formatDateTimeLocal(task.taskStart.toDate()) : '';
      document.getElementById('timeEndInput').value = task.taskEnd ? formatDateTimeLocal(task.taskEnd.toDate()) : '';
      document.getElementById('totalWorkHours').value = task.TotalWorkHours || '';
      document.getElementById('totalPauseHours').value = task.TotalPauseHours || '';
      document.getElementById('remarksInput').value = task.Remarks || '';

      taskModal.style.display = 'flex';
    });
  });
  
  document.querySelectorAll('.start-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.dataset.id;
      await startTask(id);
    });
  });
  
  document.querySelectorAll('.complete-btn').forEach(btn => {
    btn.addEventListener('click', async e => {
      e.stopPropagation();
      const id = e.target.dataset.id;
      await completeTask(id);
    });
  });
}

function formatDateTimeLocal(date) {
  if (!date) return '';
  
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}

// Render pagination with page numbers
function renderPagination(tasks) {
  paginationDiv.innerHTML = '';
  const totalPages = Math.ceil(tasks.length / rowsPerPage);
  if (totalPages <= 1) return;

  const maxVisiblePages = 5;
  const pages = [];

  // Always show first page
  pages.push(1);

  let start = Math.max(2, currentPage - 1);
  let end = Math.min(totalPages - 1, currentPage + 1);

  if (currentPage <= 3) {
    end = Math.min(4, totalPages - 1);
  } else if (currentPage >= totalPages - 2) {
    start = Math.max(totalPages - 3, 2);
  }

  if (start > 2) pages.push('...');
  for (let i = start; i <= end; i++) {
    pages.push(i);
  }
  if (end < totalPages - 1) pages.push('...');
  
  // Always show last page
  if (totalPages > 1) pages.push(totalPages);

  const prevBtn = createPageButton('Prev', currentPage === 1, () => {
    if (currentPage > 1) {
      currentPage--;
      renderTablePage(currentPage, filteredTasks);
      renderPagination(filteredTasks);
    }
  });
  paginationDiv.appendChild(prevBtn);

  pages.forEach(p => {
    const isEllipsis = p === '...';
    const btn = document.createElement('button');
    btn.textContent = p;
    btn.disabled = isEllipsis || p === currentPage;
    if (!isEllipsis && p !== currentPage) {
      btn.addEventListener('click', () => {
        currentPage = p;
        renderTablePage(currentPage, filteredTasks);
        renderPagination(filteredTasks);
      });
    }
    paginationDiv.appendChild(btn);
  });

  const nextBtn = createPageButton('Next', currentPage === totalPages, () => {
    if (currentPage < totalPages) {
      currentPage++;
      renderTablePage(currentPage, filteredTasks);
      renderPagination(filteredTasks);
    }
  });
  paginationDiv.appendChild(nextBtn);
}

function createPageButton(label, disabled, onClick) {
  const btn = document.createElement('button');
  btn.textContent = label;
  btn.disabled = disabled;
  if (!disabled) btn.addEventListener('click', onClick);
  return btn;
}

// Filter tasks based on inputs
function applyFilters() {
  const company = searchCompany.value.toLowerCase();
  const owner = searchOwner.value.toLowerCase();
  const status = statusFilter.value;
  const dateFilterValue = dateFilter.value;
  
  filteredTasks = allTasks.filter(task => {
    const matchCompany = task['Existing Company Name']?.toLowerCase().includes(company);
    const matchOwner = task.Owner?.toLowerCase().includes(owner);
    const matchStatus = !status || task.Status === status;
    
    // Date filtering
    let matchDate = true;
    if (dateFilterValue) {
      const dueDate = task['Due date'] ? new Date(task['Due date']) : null;
      
      if (dueDate) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        
        // Start of week (Monday)
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay() + (today.getDay() === 0 ? -6 : 1));
        startOfWeek.setHours(0, 0, 0, 0);
        
        // End of week (Sunday)
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        endOfWeek.setHours(23, 59, 59, 999);
        
        // Start of last week
        const startOfLastWeek = new Date(startOfWeek);
        startOfLastWeek.setDate(startOfWeek.getDate() - 7);
        
        // End of last week
        const endOfLastWeek = new Date(startOfLastWeek);
        endOfLastWeek.setDate(startOfLastWeek.getDate() + 6);
        endOfLastWeek.setHours(23, 59, 59, 999);
        
        // Start of month
        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        
        // End of month
        const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        endOfMonth.setHours(23, 59, 59, 999);
        
        // Start of last month
        const startOfLastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        
               // End of last month
        const endOfLastMonth = new Date(today.getFullYear(), today.getMonth(), 0);
        endOfLastMonth.setHours(23, 59, 59, 999);
        
        // Custom date range
        const customStart = customDateStart.value ? new Date(customDateStart.value) : null;
        const customEnd = customDateEnd.value ? new Date(customDateEnd.value) : null;
        if (customEnd) customEnd.setHours(23, 59, 59, 999);
        
        switch(dateFilterValue) {
          case 'today':
            matchDate = dueDate >= today && dueDate < tomorrow;
            break;
          case 'yesterday':
            matchDate = dueDate >= yesterday && dueDate < today;
            break;
          case 'thisWeek':
            matchDate = dueDate >= startOfWeek && dueDate <= endOfWeek;
            break;
          case 'lastWeek':
            matchDate = dueDate >= startOfLastWeek && dueDate <= endOfLastWeek;
            break;
          case 'thisMonth':
            matchDate = dueDate >= startOfMonth && dueDate <= endOfMonth;
            break;
          case 'lastMonth':
            matchDate = dueDate >= startOfLastMonth && dueDate <= endOfLastMonth;
            break;
          case 'custom':
            if (customStart && customEnd) {
              matchDate = dueDate >= customStart && dueDate <= customEnd;
            } else if (customStart) {
              matchDate = dueDate >= customStart;
            } else if (customEnd) {
              matchDate = dueDate <= customEnd;
            }
            break;
        }
      } else {
        matchDate = false; // If no due date and filtering by date
      }
    }
    
    return matchCompany && matchOwner && matchStatus && matchDate;
  });

  currentPage = 1;
  renderTablePage(currentPage, filteredTasks);
  renderPagination(filteredTasks);
}

// Attach filter input listeners
[searchCompany, searchOwner, statusFilter, dateFilter, customDateStart, customDateEnd].forEach(el =>
  el.addEventListener('input', applyFilters)
);

// Show/hide custom date inputs based on date filter selection
dateFilter.addEventListener('change', function() {
  if (this.value === 'custom') {
    customDateStart.style.display = 'inline-block';
    customDateEnd.style.display = 'inline-block';
  } else {
    customDateStart.style.display = 'none';
    customDateEnd.style.display = 'none';
  }
  applyFilters();
});

// Load tasks on page load
window.onload = loadTasks;

// Open modal on + button click
createTaskBtn.addEventListener('click', () => {
  editingTaskId = null;
  modalTitle.textContent = 'Create New Task';
  populateDropdowns();
  taskForm.reset();
  
  // Hide time editing section for new tasks
  timeEditSection.style.display = 'none';
  
  document.getElementById('timeStartInput').value = '';
  document.getElementById('timeEndInput').value = '';
  document.getElementById('totalWorkHours').value = '';
  document.getElementById('totalPauseHours').value = '';
  document.getElementById('remarksInput').value = '';
  taskModal.style.display = 'flex';
});

// Prevent modal from closing when clicking outside
taskModal.addEventListener('click', (e) => {
  // Only close if clicking directly on the modal background (not the content)
  if (e.target === taskModal) {
    // Do nothing - prevent closing
  }
});

// Close modal with cancel button or escape key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && taskModal.style.display === 'flex') {
    taskModal.style.display = 'none';
  }
});

// Populate Owner and Assigned By dropdowns from existing tasks
function populateDropdowns() {
  const owners = new Set();
  const assignedBys = new Set();
  const workTypes = new Set();
  const accountsCards = new Set();

  allTasks.forEach(task => {
    if (task.Owner) owners.add(task.Owner);
    if (task['Assigned By']) assignedBys.add(task['Assigned By']);
    if (task['TYPE OF WORK']) workTypes.add(task['TYPE OF WORK']);
    if (task['Accounts / Cards']) accountsCards.add(task['Accounts / Cards']);
  });

  ownerSelect.innerHTML = '<option value="">Select Owner</option>';
  assignedBySelect.innerHTML = '<option value="">Select Assigned By</option>';
  
  const workTypeList = document.getElementById('workTypeList');
  workTypeList.innerHTML = '';
  
  const accountsCardsList = document.getElementById('accountsCardsList');
  accountsCardsList.innerHTML = '';

  owners.forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    ownerSelect.appendChild(option);
  });

  assignedBys.forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    assignedBySelect.appendChild(option);
  });
  
  workTypes.forEach(type => {
    const option = document.createElement('option');
    option.value = type;
    workTypeList.appendChild(option);
  });
  
  accountsCards.forEach(account => {
    const option = document.createElement('option');
    option.value = account;
    accountsCardsList.appendChild(option);
  });
  
  // Add "Add New" option to both dropdowns
  const addNewOptionOwner = document.createElement('option');
  addNewOptionOwner.value = "add-new";
  addNewOptionOwner.textContent = "+ Add New Owner";
  addNewOptionOwner.classList.add('add-new');
  ownerSelect.appendChild(addNewOptionOwner);
  
  const addNewOptionAssignedBy = document.createElement('option');
  addNewOptionAssignedBy.value = "add-new";
  addNewOptionAssignedBy.textContent = "+ Add New Assigner";
  addNewOptionAssignedBy.classList.add('add-new');
  assignedBySelect.appendChild(addNewOptionAssignedBy);
}

// When user types company name, prefill if exists
companyInput.addEventListener('input', () => {
  const val = companyInput.value.trim().toLowerCase();
  if (!val) return;
  const existingTask = allTasks.find(task => (task['Existing Company Name']?.toLowerCase() === val));
  if (existingTask) {
    taskForm.elements['typeOfWork'].value = existingTask['TYPE OF WORK'] || '';
    taskForm.elements['accountType'].value = existingTask['ACCOUNT TYPE'] || '';
    taskForm.elements['accountsCards'].value = existingTask['Accounts / Cards'] || '';
    taskForm.elements['owner'].value = existingTask.Owner || '';
    taskForm.elements['assignedBy'].value = existingTask['Assigned By'] || '';
  }
});

// Handle "Add New" option in dropdowns
ownerSelect.addEventListener('change', function() {
  if (this.value === "add-new") {
    currentPersonType = "owner";
    document.getElementById('addPersonModalTitle').textContent = "Add New Owner";
    document.getElementById('newPersonName').value = '';
    addPersonModal.style.display = 'flex';
    this.selectedIndex = 0; // Reset selection
  }
});

assignedBySelect.addEventListener('change', function() {
  if (this.value === "add-new") {
    currentPersonType = "assignedBy";
    document.getElementById('addPersonModalTitle').textContent = "Add New Assigner";
    document.getElementById('newPersonName').value = '';
    addPersonModal.style.display = 'flex';
    this.selectedIndex = 0; // Reset selection
  }
});

// Handle adding new person
addPersonForm.addEventListener('submit', function(e) {
  e.preventDefault();
  
  const name = newPersonName.value.trim();
  if (!name) {
    alert('Please enter a name');
    return;
  }
  
  // Add the new person to the appropriate dropdown
  if (currentPersonType === "owner") {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    ownerSelect.insertBefore(option, ownerSelect.lastChild);
    ownerSelect.value = name;
  } else if (currentPersonType === "assignedBy") {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    assignedBySelect.insertBefore(option, assignedBySelect.lastChild);
    assignedBySelect.value = name;
  }
  
  addPersonModal.style.display = 'none';
});

// Generate SINO: generates globally incremented SINO ignoring company name
function generateSINO() {
  let maxNumber = 0;
  allTasks.forEach(task => {
    if (task.SINO) {
      const match = task.SINO.match(/(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        if (num > maxNumber) maxNumber = num;
      }
    }
  });

  const nextNumber = maxNumber + 1;
  return String(nextNumber).padStart(3, '0');
}

function cleanUndefined(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([_, v]) => v !== undefined)
  );
}

// Calculate time difference between two timestamps
function calculateTimeDifference(start, end) {
  if (!start || !end) return { hours: 0, minutes: 0 };
  
  let startTime, endTime;
  
  // Handle Firestore timestamps
  if (start.toDate) {
    startTime = start.toDate();
  } else if (start instanceof Date) {
    startTime = start;
  } else {
    startTime = new Date(start);
  }
  
  if (end.toDate) {
    endTime = end.toDate();
  } else if (end instanceof Date) {
    endTime = end;
  } else {
    endTime = new Date(end);
  }
  
  const diffMs = endTime - startTime;
  
  const hours = Math.floor(diffMs / (1000 * 60 * 60));
  const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
  
  return { hours, minutes };
}

// Update time display when start/end times change
document.getElementById('timeStartInput').addEventListener('change', updateTimeDisplay);
document.getElementById('timeEndInput').addEventListener('change', updateTimeDisplay);

function updateTimeDisplay() {
  const startTime = document.getElementById('timeStartInput').value;
  const endTime = document.getElementById('timeEndInput').value;
  
  if (startTime && endTime) {
    const { hours, minutes } = calculateTimeDifference(new Date(startTime), new Date(endTime));
    document.getElementById('totalWorkHours').value = `${hours}h ${minutes}m`;
  }
}

taskForm.addEventListener('submit', async (e) => {
  e.preventDefault();

  const formData = new FormData(taskForm);
  const data = {};

  formData.forEach((value, key) => {
    data[key] = value.trim();
  });

  if (!data.company || !data.typeOfWork || !data.dueDate || !data.owner || !data.assignedBy) {
    alert('Please fill in all required fields.');
    return;
  }

  // Handle time inputs
  const timeStartInput = document.getElementById('timeStartInput').value;
  const timeEndInput = document.getElementById('timeEndInput').value;
  const remarksInput = document.getElementById('remarksInput').value;
  
  let taskStart = null;
  let taskEnd = null;
  
  if (timeStartInput) {
    taskStart = firebase.firestore.Timestamp.fromDate(new Date(timeStartInput));
  }
  
  if (timeEndInput) {
    taskEnd = firebase.firestore.Timestamp.fromDate(new Date(timeEndInput));
  }

  const taskData = {
    SINO: editingTaskId ? undefined : generateSINO(),
    Status: editingTaskId ? undefined : 'Not Started',
    'Existing Company Name': data.company,
    'TYPE OF WORK': data.typeOfWork,
    'ACCOUNT TYPE': data.accountType || '',
    'Accounts / Cards': data.accountsCards || '',
    Task: data.task || '',
    Owner: data.owner,
    'WORK FOR': data.workFor || '',
    PERIOD: data.period || '',
    'Due date': data.dueDate,
    'Assigned By': data.assignedBy,
    Notes: data.notes || '',
    taskStart: taskStart,
    taskEnd: taskEnd,
    TimeStarted: timeStartInput ? new Date(timeStartInput).toLocaleString() : '',
    TimeEnd: timeEndInput ? new Date(timeEndInput).toLocaleString() : '',
    TotalWorkHours: document.getElementById('totalWorkHours').value,
    TotalPauseHours: document.getElementById('totalPauseHours').value,
    Remarks: remarksInput || ''
  };

  try {
    if (editingTaskId) {
      const existingTask = allTasks.find(t => t.id === editingTaskId);
      if (!existingTask) throw new Error("Task not found for editing.");

      const mergedTask = { ...existingTask, ...cleanUndefined(taskData) };

      await db.collection('tasks').doc(editingTaskId).set(mergedTask);
      alert('Task updated successfully!');
      editingTaskId = null;
    } else {
      await db.collection('tasks').add(taskData);
      alert('Task created successfully!');
    }

    taskModal.style.display = 'none';
    loadTasks();
  } catch (err) {
    console.error('Error saving task:', err);
    alert('Error saving task. See console for details.');
  }
});

// Update Accounts/Cards list based on company and account type
const accountTypeSelect = taskForm.elements['accountType'];
const accountsCardsList = document.getElementById('accountsCardsList');

function updateAccountsCardsList() {
  const company = companyInput.value.trim();
  const accountType = accountTypeSelect.value;

  accountsCardsList.innerHTML = '';

  if (!company) return;

  const cardsSet = new Set();

  allTasks.forEach(task => {
    const taskCompany = task['Existing Company Name'] || '';
    const taskAccountType = task['ACCOUNT TYPE'] || '';

    if (
      taskCompany.toLowerCase() === company.toLowerCase() &&
      taskAccountType.toLowerCase() === accountType.toLowerCase() &&
      task['Accounts / Cards']
    ) {
      cardsSet.add(task['Accounts / Cards']);
    }
  });

  cardsSet.forEach(card => {
    const option = document.createElement('option');
    option.value = card;
    accountsCardsList.appendChild(option);
  });
}

// Add event listeners to update Accounts / Cards dynamically
companyInput.addEventListener('input', updateAccountsCardsList);
accountTypeSelect.addEventListener('change', updateAccountsCardsList);

// Show/hide period input based on WORK FOR selection
document.getElementById('workForSelect').addEventListener('change', function () {
  const val = this.value;
  const period = document.getElementById('periodInput');
  if (val) {
    period.style.display = 'inline-block';
    period.placeholder = `${val} Period`;
  } else {
    period.style.display = 'none';
  }
});

// CSV Upload functionality
uploadCSVBtn.addEventListener('click', () => {
  csvUpload.click();
});

csvUpload.addEventListener('change', handleCSVUpload);

async function handleCSVUpload(event) {
  const file = event.target.files[0];
  if (!file) return alert('No file selected.');

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    complete: async function (results) {
      const rows = results.data;

      const requiredHeaders = ['SINO', 'Company', 'Type of Work', 'Owner', 'DueDate', 'Assigned By', 'Status'];
      const csvHeaders = Object.keys(rows[0]);

      const hasAllRequired = requiredHeaders.every(h => csvHeaders.includes(h));
      if (!hasAllRequired) return alert('Missing required headers in CSV.');

      const tasksToUpload = [];

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const dueDateStr = row['DueDate'];
        const timeStartStr = row['Time Started'];
        const timeEndStr = row['Time End'];

        let timeStart = null, timeEnd = null;
        try {
          // Convert to valid Date
          timeStart = timeStartStr ? new Date(timeStartStr) : null;
          timeEnd = timeEndStr ? new Date(timeEndStr) : null;
        } catch (e) {
          console.warn(`Invalid time format in row ${i + 2}`);
        }

        const workSessions = (timeStart && timeEnd)
          ? [{
              start: firebase.firestore.Timestamp.fromDate(timeStart),
              end: firebase.firestore.Timestamp.fromDate(timeEnd)
            }]
          : [];

        const finalTask = {
          SINO: row['SINO'],
          'Existing Company Name': row['Company'],
          'TYPE OF WORK': row['Type of Work'],
          'ACCOUNT TYPE': row['Account Type'],
          'Accounts / Cards': row['Accounts / Cards'],
          Task: row['Task'],
          Owner: row['Owner'],
          'WORK FOR': row['Work For'],
          PERIOD: row['Period'],
          'Due date': row['DueDate'],
          'Assigned By': row['Assigned By'],
          Notes: row['Notes'],
          Status: row['Status'] || 'Not Started',

          TimeStarted: timeStart ? timeStart.toLocaleString() : '',
          TimeEnd: timeEnd ? timeEnd.toLocaleString() : '',
          taskStart: timeStart ? firebase.firestore.Timestamp.fromDate(timeStart) : null,
          taskEnd: timeEnd ? firebase.firestore.Timestamp.fromDate(timeEnd) : null,

          TotalWorkHours: row['Total Work Hours'] || '',
          TotalPauseHours: row['Total Pause Hours'] || '',
          Remarks: row['Remarks'] || '',
          workSessions
        };

        tasksToUpload.push(finalTask);
      }

      try {
        const batch = db.batch();
        const tasksRef = db.collection('tasks');

        tasksToUpload.forEach(task => {
          const newDoc = tasksRef.doc();
          batch.set(newDoc, task);
        });

        await batch.commit();
        alert(`${tasksToUpload.length} tasks uploaded successfully.`);
        loadTasks(); // Reload the task table
      } catch (err) {
        console.error('Error uploading tasks:', err);
        alert('Failed to upload tasks. See console for details.');
      }
    },
    error: function (err) {
      console.error("PapaParse error:", err);
      alert("CSV parsing failed.");
    }
  });
}

// Download CSV Template
downloadTemplateBtn.addEventListener('click', downloadCSVTemplate);

function downloadCSVTemplate() {
  // Create sample data for the template
  const sampleData = [
    {
      'SINO': '001',
      'Company': 'ABC Corporation',
      'Type of Work': 'Account Reconciliation',
      'Account Type': 'Saving Acc',
      'Accounts / Cards': 'Account 12345',
      'Task': 'Monthly reconciliation',
      'Owner': 'John Doe',
      'Work For': 'Monthly',
      'Period': 'January 2023',
      'DueDate': '2023-01-31',
      'Assigned By': 'Manager',
      'Notes': 'Complete reconciliation by end of month',
      'Status': 'Not Started',
      'Time Started': '2023-01-15T09:00',
      'Time End': '2023-01-15T17:00',
      'Total Work Hours': '8h 0m',
      'Total Pause Hours': '1h 0m',
      'Remarks': 'Completed successfully'
    },
    {
      'SINO': '002',
      'Company': 'XYZ Ltd',
      'Type of Work': 'Tax Filing',
      'Account Type': 'Chequing Acc',
      'Accounts / Cards': 'Account 67890',
      'Task': 'Quarterly tax filing',
      'Owner': 'Jane Smith',
      'Work For': 'Quarterly',
      'Period': 'Q1 2023',
      'DueDate': '2023-04-15',
      'Assigned By': 'Supervisor',
      'Notes': 'File quarterly taxes',
      'Status': 'In Progress',
      'Time Started': '2023-04-01T10:00',
      'Time End': '2023-04-01T16:30',
      'Total Work Hours': '6h 30m',
      'Total Pause Hours': '0h 30m',
      'Remarks': 'In progress'
    }
  ];

  // Convert to CSV
  const csv = Papa.unparse(sampleData);
  
  // Create and download the file
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', 'task_template.csv');
  link.style.visibility = 'hidden';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
</script>
</body>
</html>